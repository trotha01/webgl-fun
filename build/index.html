<!DOCTYPE HTML>
<html>
  <head>
    <title>WebGL Fun</title>
    <meta charset='utf-8'/>
    <link rel='stylesheet' href='style.css' type='text/css'>
    <script src="utility.js"></script>
    <script src="gl-matrix-min.js"></script>
    <script src="noise3D.js"></script>
    <!-- script type='text/javascript' src='../elm.js'></script -->
  </head>

  <body>
    <div id="elm"></div>
    <img src="data:image/png;base64,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" id="icon" hidden />
    <!--
    <canvas id="game-canvas" height=400 width=400>Your browser does not seem to support
      HTML5 canvas.</canvas>
    -->

    <canvas id="transform-feedback" height=400 width=400>Your browser does not seem to support
      HTML5 canvas.</canvas>

    <script>
/*
var app = Elm.Main.init({
        node: document.getElementById('elm')
      });

      app.ports.runGL.subscribe(function(data) {
        console.log('runGL')
      })
 */
    </script>
    <!--
    <script type='text/javascript' src='gl.js'></script>
    <script type='text/javascript' src='game.js'></script>
    -->

    <!-- WebGL 2 shaders -->
    <script id="vs-calc" type="x-shader/x-vertex">
        #version 300 es
        #define POSITION_LOCATION 0
        #define VELOCITY_LOCATION 1
        #define SPAWNTIME_LOCATION 2
        #define ID_LOCATION 3

        precision highp float;
        precision highp int;
        precision highp sampler3D;

        uniform float u_time;
        uniform sampler2D texFramebuffer;

        // Possible optimization: compact in/out to one vector buffer
        // maybe try interface blocks?
        layout(location = POSITION_LOCATION) in vec2 a_position;
        layout(location = VELOCITY_LOCATION) in vec2 a_velocity;
        layout(location = SPAWNTIME_LOCATION) in float a_spawntime;
        layout(location = ID_LOCATION) in float a_ID;

        out vec2 v_position;
        out vec2 v_velocity;
        out float v_spawntime;

        mat2 a;
        vec2 b;
        vec4 pixel;
        vec2 velocity1;
        vec2 velocity2;

        float v1ix, v1fx, v2ix, v2fx; // one dimensional vectors for now
        float v1iy, v1fy, v2iy, v2fy; // one dimensional vectors for now
        float m1 = 1.0;
        float m2 = 1.0;
        vec2 v12fx, v12fy, v1f;

        // float canvas_size = 400.0;
        // float pix_size = 1.0 / 400.0;

        float rand(vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        vec2 walls(vec2 position, vec2 velocity) {
          if (position.x >= 1.0 || position.x <= -1.0) {
            return vec2(-velocity.x, velocity.y);
          }
          if (position.y >= 1.0 || position.y <= -1.0) {
            return vec2(velocity.x, -velocity.y);
          }
          return velocity;
        }

        vec2 texCoordFromPos(vec2 position) {
          return vec2((position.x + 1.0)/2.0, (position.y + 1.0)/2.0);
        }

        vec2 collide(vec2 v1, vec2 v2) {
          v1ix = v1.x;
          v1iy = v1.y;
          v2ix = v2.x;
          v2iy = v2.y;

          // We have the two equations for elastic collisions:
          // v1i + v1f = v2i + v2f
          // m1 * v1i + m2 * v2i = m1 * v1f + m2 * v2f;
          // We have all the above variables, except v1f and v2f
          // this means we have two equations with two unknown.
          // We can transform this into the equation:
          // | 1 -1  | * | v1f | = | v2i - v1i           |
          // | m1 m2 |   | v2f |   | m1 * v1i + m2 * v2i |
          //    a      *    x    = b
          //
          // Then solve for the [ v1f, v2f] vector.
          //    x                = a ^ -1 * b
          // We solve the above for both the x and y dimensions
          // then only keep the v1f result.
          a = mat2(1, m1, -1, m2);
          b = vec2(v2ix - v1ix, m1 * v1ix + m2 * v2ix);
          v12fx = vec2(inverse(a) * b);
          v1fx = v12fx.x;
          b = vec2(v2iy - v1iy, m1 * v1iy + m2 * v2iy);
          v12fy = vec2(inverse(a) * b);
          v1fy = v12fy.x;
          return vec2(v1fx, v1fy);
          // return velocity;
        }

        void main()
        {
            if (a_spawntime == 0.0) {
                // Generate a new particle
                v_position = vec2(a_ID/10.0, 0.0);
                v_velocity = vec2(rand(vec2(a_ID, 0.0)) - 0.5, rand(vec2(a_ID, a_ID)));
                v_spawntime = u_time;
            } else {
                velocity1 = walls(a_position, a_velocity);
                pixel = texture(texFramebuffer, texCoordFromPos(v_position)); // get pixel at position
                v1f = velocity1;
                if (pixel.x > 0.0 && pixel.y > 0.0) {
                  v1f = collide(velocity1, vec2(pixel));
                }

                v_velocity = v1f;
                v_position = a_position + 0.01 * v_velocity;


                v_spawntime = a_spawntime;
            }

            gl_Position = vec4(v_position, 0.0, 1.0);
            // gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);
            // gl_PointSize = 64.0;
            gl_PointSize = 8.0;
        }
    </script>

    <script id="fs-calc" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        precision highp int;

        uniform sampler2D atomTexture;

        in vec2 v_velocity;

        out vec4 color;

        vec4 pixel;

        void main()
        {
            // color = vec4(gl_PointCoord, 0.0, 1.0);
            // color = vec4(v_position, 0.0, 1.0);
            // color = texture(atomTexture, vec2(gl_FragCoord));
            // color = vec4(0, 0, 1, 1);
            // color = texture(atomTexture, vec2(1, 1));
            // color = texture(atomTexture, vec2(gl_PointCoord));

            // pixel = texture(atomTexture, vec2(1, 1));
            pixel = texture(atomTexture, vec2(gl_PointCoord));
            color = vec4(v_velocity.x, v_velocity.y, 1, pixel.a);
            // color = texture(atomTexture, vec2(1, 1));
        }
    </script>

    <script type='text/javascript' src='transformfeedbackcopy.js'></script>

  </body>
</html>

